---
title: "Analysis: Model Recovery"
format: 
  html:
    theme:
      light: yeti
      dark: superhero
    fontsize: small
    grid:
      sidebar-width: 15em
    code-fold: true
    toc: true
    toc-location: left
    toc-title: Contents
    toc-depth: 3
    toc-expand: true
    embed-resources: true
    html-math-method: katex
editor: source
---

# Setup

## Libraries

```{r}
# Libraries
library(here)
library(data.table)
library(parallel)
library(magrittr)
library(ggplot2)
library(ggh4x)
library(viridis)
```

## Source functions

```{r}
base_path = file.path(here::here(),
                      'code',
                      fsep = .Platform$file.sep)
source(file.path(base_path, 'utils', 'Neurocodify_plot.R',
                 fsep = .Platform$file.sep))
source(file.path(base_path, 'model_fitting', 'LRfunction.R',
                 fsep = .Platform$file.sep))
```

## Load data

```{r}
# Glob files based on naming pattern
load_path = file.path(here::here(),
                      'derivatives',
                      'parameter_recovery',
                      fsep = .Platform$file.sep)
# Load data with fixed betas during simulation
files = Sys.glob(file.path(load_path,
                           'modelrecov_base-*_randips-TRUE_randbetas-FALSE_randsvs-TRUE.tsv',
                           fsep = .Platform$file.sep))

# Function to load text files (.tsv)
Load_tsv = function(file_path){
  tsv = data.table::fread(file_path,
                          sep = '\t',
                          na.strings = 'n/a')
  return(tsv)
}

# Get list of all text files using parallel processing
data_list = parallel::mclapply(X = files,
                               FUN = Load_tsv,
                               mc.cores = 4)
# Bind individual list entries (loaded text files) to single data frame
# (using optimized bind function by data.table package)
data = data.table::rbindlist(data_list) %>%
  # Rename to avoid 'x' as column name
  data.table::setnames(., old = 'x', new = 'params')
```

# Model recovery

```{r}
data_recovery = data %>%
  # For each model that generated data, get AICc for all fitted models
  .[, .(AICc = unique(AICc)),
    by = c('participant_id',
           'generating_model',
           'iter',
           'model',
           'generating_x1',
           'generating_x2',
           'generating_x3',
           'generating_x4')] %>%
  # Get winning model of recovery (lowest AICc)
  .[, recovered_model := model[which(AICc == min(AICc))],
    by = c('participant_id',
           'generating_model',
           'iter')] %>%
  # Get match between generating/recovered model
  .[, correct_recovery := generating_model == recovered_model] %>%
  # Factorize variables and sort factor levels in matching manner
  .[, c('generating_model', 'recovered_model') := lapply(.SD, factor),
    .SDcols = c('generating_model', 'recovered_model')] %>%
  .[, recovered_model := factor(recovered_model, levels = levels(generating_model))]
```

## Histogram matrix

```{r}
# Plot recovery as histogram
data_plot = data_recovery %>%
  # Reduce to row for each attempted recovery
  .[, .(recovered_model = unique(recovered_model)),
    by = c('participant_id', 'generating_model', 'iter')] %>%
  # Get matching model for each generative model to mark it in plot
  .[, correct_model := as.character(recovered_model) == as.character(generating_model)]
p = ggplot(data = data_plot,
           aes(x = recovered_model,
               color = correct_model)) +
  scale_color_manual(values = c('transparent', 'black')) +
  geom_bar(fill = 'lightgrey') +
  labs(x = 'Recovered Model',
       title = 'Model recovery: Recovered models for each generating model') + 
  facet_grid(generating_model ~ .,
             switch = 'y')
Neurocodify_plot(p) +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.text.x = element_text(angle = 25,
                                   hjust = 1,
                                   vjust = 1),
        axis.title.y = element_blank(),
        plot.title = element_text(face = 'bold',
                                  hjust = 0.5),
        strip.placement = 'outside',
        strip.text.y.left = element_text(size = 10,
                                  face = 'bold',
                                  angle = 0,
                                  hjust = 1),
        legend.position = 'none',
        aspect.ratio = 1/6)
```

## Confusion matrix

```{r}
# Plot recovery as CM
data_plot = data_recovery %>%
  # Reduce to row for each attempted recovery
  .[, .(recovered_model = unique(recovered_model)),
    by = c('participant_id', 'generating_model', 'iter')] %>%
  .[, .(count = .N),
    by = c('recovered_model', 'generating_model')] %>%
  data.table::setorder('generating_model') %>%
  .[, perc := count/sum(count),
    by = 'generating_model'] %>%
  .[, sum_perc := sum(perc),
    by = 'generating_model'] %>%
  .[, label_short := substr(format(round(perc, 2), nsmall = 2), 2,4)] %>%
  .[, is_low := perc < 0.4]

p = ggplot(data = data_plot,
           aes(x = recovered_model,
               y = generating_model,
               fill = perc,
               color = is_low,
               label = label_short)) +
  geom_tile(color = 'black') +
  geom_text() +
  labs(x = 'Fit model',
       y = 'Simulated model') +
  theme(panel.background = element_rect(fill = NA,
                                        color = NA),
        panel.grid = element_blank(),
        legend.position = 'none',
        axis.title = element_text(size = 12, face = 'bold'),
        axis.ticks = element_blank(),
        strip.text = element_blank(),
        strip.background = element_blank(),
        plot.title = element_text(hjust = 0.5,
                                  vjust = 0),
        #axis.text = element_text(size = 12),
        plot.margin = margin(0,0,0,0,'pt')) +
  scale_y_discrete(limits = rev) +
  scale_color_manual(values = c('black', 'white')) +
  scale_fill_gradient(low = 'black', high = 'white')
p
```


## Recovery success

```{r}
# Overall recovery
data_plot = data_recovery %>%
  # Reduce to row for each attempted recovery
  .[, .(recovered_model = unique(recovered_model)),
    by = c('participant_id', 'generating_model', 'iter')] %>%
  # Get matching model for each generative model to mark it in plot
  .[, correct_model := as.character(recovered_model) == as.character(generating_model)] %>%
  # Recode correct model to successful recovery (if correct model was recovered,
  # recovery was successful)
  .[, successful_recovery := correct_model]
p = ggplot(data = data_plot,
           aes(x = successful_recovery,
               fill = successful_recovery)) +
  geom_bar(color = 'transparent') +
  scale_fill_manual(values = c('red', 'lightgreen')) +
  facet_grid(generating_model ~.,
             switch = 'y')
Neurocodify_plot(p) +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(face = 'bold',
                                  hjust = 0.5),
        strip.placement = 'outside',
        strip.text.y.left = element_text(size = 10,
                                  face = 'bold',
                                  angle = 0,
                                  hjust = 1),
        legend.position = 'none')
```

## Restricted to reasonable parameters

```{r}
# Set gap between parameters
gap = 0.4

data_recovery_gap = data %>%
  # For each model that generated data, get AICc for all fitted models
  .[, .(AICc = unique(AICc)),
    by = c('participant_id',
           'generating_model',
           'iter',
           'model',
           'generating_x1',
           'generating_x2',
           'generating_x3',
           'generating_x4')] %>%
  # Restrict data to seplr and surprise
  .[generating_model %in% c('surprise', 'seplr')] %>%
  # Add column if parameter combinations are different (SEPLR & Surprise)
  .[, different := FALSE] %>%
  # Get abs difference between parameters
  .[, diff := abs(generating_x1 - generating_x2)] %>%
  # Select only entries in which difference is large enough to not be too close to RW
  .[diff >= gap, different := TRUE] %>%
  .[different == TRUE,] %>%
  # Get winning model of recovery (lowest AICc)
  .[, recovered_model := model[which(AICc == min(AICc))],
    by = c('participant_id',
           'generating_model',
           'iter')] %>%
  # Get match between generating/recovered model
  .[, correct_recovery := generating_model == recovered_model]
```

```{r}
# Plot recovery as histogram
data_plot_cm = data_recovery_gap %>%
  # Reduce to row for each attempted recovery
  .[, .(recovered_model = unique(recovered_model)),
    by = c('participant_id', 'generating_model', 'iter')] %>%
  .[, .(count = .N),
    by = c('recovered_model', 'generating_model')] %>%
  data.table::setorder('generating_model') %>%
  .[, perc := count/sum(count),
    by = 'generating_model'] %>%
  .[, sum_perc := sum(perc),
    by = 'generating_model'] %>%
  .[, label_short := substr(format(round(perc, 2), nsmall = 2), 2,4)] %>%
  .[, is_low := perc < 0.4]
  
p = ggplot(data = data_plot_cm,
           aes(x = recovered_model,
               y = generating_model,
               fill = perc,
               color = is_low,
               label = label_short)) +
  geom_tile(color = 'black') +
  geom_text() +
  labs(x = 'Fit model',
       y = 'Simulated model',
       title = paste0('Model recov CM (min LR difference of ', gap, ')')) +
  theme(panel.background = element_rect(fill = NA,
                                        color = NA),
        panel.grid = element_blank(),
        legend.position = 'none',
        axis.title = element_text(size = 12, face = 'bold'),
        axis.ticks = element_blank(),
        strip.text = element_blank(),
        strip.background = element_blank(),
        plot.title = element_text(hjust = 0.5,
                                  vjust = 0),
        #axis.text = element_text(size = 12),
        plot.margin = margin(0,0,0,0,'pt')) +
  scale_y_discrete(limits = rev) +
  scale_color_manual(values = c('black', 'white')) +
  scale_fill_gradient(low = 'black', high = 'white')
p
```

```{r}
# Plot recovery as histogram
data_plot = data_recovery_gap %>%
  # Reduce to row for each attempted recovery
  .[, .(recovered_model = unique(recovered_model)),
    by = c('participant_id', 'generating_model', 'iter')] %>%
  # Get matching model for each generative model to mark it in plot
  .[, correct_model := as.character(recovered_model) == as.character(generating_model)]

p = ggplot(data = data_plot,
           aes(x = recovered_model,
               color = correct_model)) +
  scale_color_manual(values = c('transparent', 'black')) +
  geom_bar(fill = 'lightgrey') +
  labs(x = 'Recovered Model',
       title = paste0('Fit models for each sim model (min LR difference of ', gap, ')')) + 
  facet_grid(generating_model ~ .,
             switch = 'y')
Neurocodify_plot(p) +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.text.x = element_text(angle = 25,
                                   hjust = 1,
                                   vjust = 1),
        axis.title.y = element_blank(),
        plot.title = element_text(face = 'bold',
                                  hjust = 0.5),
        strip.placement = 'outside',
        strip.text.y.left = element_text(size = 10,
                                  face = 'bold',
                                  angle = 0,
                                  hjust = 1),
        legend.position = 'none',
        aspect.ratio = 1/6)

```

### Which LRs did RW have when it was recovered from surprise and valence simulaions?

```{r}
data_false_rw = data %>%
  # Restrict to Valence and Surprise model
  .[generating_model %in% c('seplr', 'surprise'),] %>%
   # Get winning model of recovery (lowest AICc)
  .[, min_AICc := min(AICc),
    by = c('participant_id',
           'generating_model',
           'iter')] %>%
  .[, best_fit := AICc == min_AICc] %>%
  .[best_fit == TRUE] %>%
  # Rename model to recovered_model, because only best fitting model remains in data
  data.table::setnames(old = 'model', new = 'recovered_model') %>%
  # Select false recovery of RW
  .[recovered_model == 'rw',] %>%
  # Get LRs of RW models that were falsely recovered
  .[variable == 'coefs' & params == 'alpha',] %>%
  # Add column if parameter combinations are different (SEPLR & Surprise)
  .[, different := FALSE] %>%
  # Get abs difference between parameters
  .[, diff := abs(generating_x1 - generating_x2)] %>%
  # Select only entries in which difference is large enough to not be too close to RW
  .[diff >= gap, different := TRUE]

# Plot
p = ggplot(data = data_false_rw,
           aes(x = generating_model,
               y = value,
               color = generating_model,
               fill = generating_model)) +
  geom_point(position = position_jitter(width = 0.05,
                                        height = 0,
                                        seed = 666),
             size = 0.5,
             alpha = 0.5) +
  geom_boxplot(outlier.shape = NA,
               color = 'black',
               width = 0.2,
               position = position_nudge(x = -0.2,
                                         y = 0)) +
  stat_summary(geom = 'point',
               fun = mean,
               shape = 23,
               size = 3,
               stroke = 1,
               fill = 'white',
               color = 'black',
               position = position_nudge(x = -0.2,
                                         y = 0)) +
  gghalves::geom_half_violin(side = 'R',
                             alpha = 0.8,
                             color = NA,
                             width = 0.5,
                             position = position_nudge(x = 0.1,
                                                       y = 0)) +
  facet_wrap(~different)
p = Neurocodify_plot(p) +
  theme(legend.position = 'none')
p
  
```

### Recovery if RW is restricted to reasonable alpha values (for stationary enviroments)

```{r}
# Set cut-off that is considered implausible alpha for RW in stationay environment
cut_off = 0.5

data_recov_plausible = data %>%
  # Restrict to Valence and Surprise model
  .[generating_model %in% c('seplr', 'surprise'),] %>%
  # Get relevant information for each fit
  .[, .(AICc = unique(AICc),
        recovered_alpha = value[variable == 'coefs' & params == 'alpha']),
    by = c('participant_id', 'model', 'iter', 'generating_model')] %>%
  # Add column separating data in high or low alpha in recovered RWs
  .[, high_alpha := FALSE] %>%
  .[model == 'rw', high_alpha := recovered_alpha > cut_off] %>%
  # Eliminate uncertainty alphas (they shared the parameter name)
  .[model == 'uncertainty', recovered_alpha := as.numeric(NA)] %>%
  # Remove all RW recoveries in which implausible alpha was recovered
  .[high_alpha == FALSE,] %>%
  # Get winning model of recovery (lowest AICc)
  .[, recovered_model := model[which(AICc == min(AICc))],
    by = c('participant_id',
           'generating_model',
           'iter',
           'recovered_alpha')] 

data_plot_cm = data_recov_plausible %>%
  # Reduce to row for each attempted recovery
  .[, .(recovered_model = unique(recovered_model)),
    by = c('participant_id', 'generating_model', 'iter')] %>%
  .[, .(count = .N),
    by = c('recovered_model', 'generating_model')] %>%
  data.table::setorder('generating_model') %>%
  .[, perc := count/sum(count),
    by = 'generating_model'] %>%
  .[, sum_perc := sum(perc),
    by = 'generating_model'] %>%
  .[, label_short := substr(format(round(perc, 2), nsmall = 2), 2,4)] %>%
  .[, is_low := perc < 0.4]
  
p = ggplot(data = data_plot_cm,
           aes(x = recovered_model,
               y = generating_model,
               fill = perc,
               color = is_low,
               label = label_short)) +
  geom_tile(color = 'black') +
  geom_text() +
  labs(x = 'Fit model',
       y = 'Simulated model',
       title = paste0('Model recov CM (max allowed LR in RW = ', cut_off, ')')) +
  theme(panel.background = element_rect(fill = NA,
                                        color = NA),
        panel.grid = element_blank(),
        legend.position = 'none',
        axis.title = element_text(size = 12, face = 'bold'),
        axis.ticks = element_blank(),
        strip.text = element_blank(),
        strip.background = element_blank(),
        plot.title = element_text(hjust = 0.5,
                                  vjust = 0),
        #axis.text = element_text(size = 12),
        plot.margin = margin(0,0,0,0,'pt')) +
  scale_y_discrete(limits = rev) +
  scale_color_manual(values = c('black', 'white')) +
  scale_fill_gradient(low = 'black', high = 'white')
p
```



