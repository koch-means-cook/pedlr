---
title: "Model fitting"
output:
  html_document:
    toc: yes
    self_contained: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 3
    number_sections: False
    highlight: pygments
    theme: cosmo
    code_folding: "hide"
    df_print: paged
    fig_caption: true
  pdf_document:
    toc: yes
    fig_caption: true
    latex_engine: xelatex
fig.align: "center"
header-includes:
  - \usepackage{fontspec}
  - \setmainfont{AgfaRotisSansSerif}
email: koch@mpib-berlin.mpg.de
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
library(data.table)
library(here)
library(magrittr)
library(ggplot2)
library(viridis)
library(binhf)
library(plotly)
```

```{r}
# Get directory of repository
base_path = here::here()

# Load pre-written functions
source_path = file.path(base_path, 'code', 'utils',
                        fsep = .Platform$file.sep)
source_files = list.files(source_path, pattern = "[.][rR]$",
                          full.names = TRUE, recursive = TRUE)
invisible(lapply(source_files, function(x) source(x)))

# Load models
source_path = file.path(base_path, 'code', 'models',
                        fsep = .Platform$file.sep)
source_files = list.files(source_path, pattern = "[.][rR]$",
                          full.names = TRUE, recursive = TRUE)
invisible(lapply(source_files, function(x) source(x)))

# Load apply function
source_path = file.path(base_path, 'code', 'simulation', 'Apply_model.R',
                        fsep = .Platform$file.sep)
source(source_path)

# Load fitting function
source_path = file.path(base_path, 'code', 'model_fitting', 'Fit_model.R',
                        fsep = .Platform$file.sep)
source(source_path)
```

```{r}
# Load data
data = Load_data() %>%
  Add_comp(.) %>%
  .[participant_id == '158HUXE' & task_version == 1, ] %>%
  Prepare_data_for_fit(.)
```

# Rw

## Simulate data

```{r}
true_parameters = data.frame(alpha = 0.2,
                             temperature = 7,
                             reward_space_ub = 100,
                             choice_policy = 'softmax')

# Change choices of data to that of a Rw model
source_model = Rw(design = data,
                  params.alpha = true_parameters$alpha,
                  params.temperature = true_parameters$temperature,
                  params.reward_space_ub = true_parameters$reward_space_ub,
                  choice_policy = true_parameters$choice_policy,
                  init_values = c(50,50,50))
# Use design of real participant to make simulated data (as if model had played design that was presented to participant)
simulated_data = data %>%
  .[, ':='(choice = source_model$choices$choice,
           choice_prob = source_model$choices$choice_prob,
           forced_choice = source_model$choices$forced_choice,
           v_stim_1 = source_model$values$stim_1,
           v_stim_2 = source_model$values$stim_2,
           v_stim_3 = source_model$values$stim_3,
           # No errors possible in simulation
           error = FALSE)] %>%
  # Add comparison type for each trial (e.g. 1v2)
  Add_comp(.) %>%
  # Update outcome to reflect choice of model, not of participant
  .[, trial := seq(.N)] %>%
  .[, outcome := c(reward_stim_1, reward_stim_2)[which(c(option_left, option_right) == choice)],
    by = trial] %>%
  .[, c('option_left', 'option_right', 'reward_stim_1', 'reward_stim_2','error', 'outcome', 'trial_type', 'forced_left', 'forced_right',
        'choice', 'choice_prob', 'forced_choice',
        'v_stim_1', 'v_stim_2', 'v_stim_3', 'comp')]
```

## Grid search (alpha)

```{r}
grid_search_ll = data.table()
grid_search_data = data.table()

for(alpha in seq(0,1, by = 0.01)){
  # Set paremeters for each loop
  parameters = data.frame(alpha = alpha,
                          temperature = true_parameters$temperature,
                          reward_space_ub = true_parameters$reward_space_ub,
                          choice_policy = true_parameters$choice_policy)
  # Fit model to simulated data with the given parameters
  fitted_model = Fit_Rw(data = simulated_data,
                        params.alpha = parameters$alpha,
                        params.temperature = parameters$temperature,
                        params.reward_space_ub = parameters$reward_space_ub,
                        choice_policy = parameters$choice_policy,
                        init_values = c(50,50,50))
  # Combine simulated data and fit results into one data frame (add columns of fitting process, like model choices and estimates)
  test_data = simulated_data %>%
    .[, ':='(Rw_choice = fitted_model$choices$choice,
             Rw_choice_prob = fitted_model$choices$choice_prob,
             Rw_forced_choice = fitted_model$choices$forced_choice,
             Rw_v_1 = fitted_model$values$stim_1,
             Rw_v_2 = fitted_model$values$stim_2,
             Rw_v_3 = fitted_model$values$stim_3)]
  
  # Get choices of participant
  choices_participant = simulated_data$choice
  # Get choices and probability of choices from model
  choices_model = fitted_model$choices$choice
  choices_prob_model = fitted_model$choices$choice_prob
  
  # Get forced choices to exclude from likelihood calculation (since here there is no
  # choice probability and in turn no likelihood of choice)
  index_fc = which((simulated_data$trial_type == 'forced'))
  
  # Get time out trials (outcome = NA) to exclude
  index_to = which(is.na(simulated_data$outcome))
  
  # Exclude forced choices and time outs
  index_excl = unique(sort(c(index_fc, index_to)))
  choices_prob_model = choices_prob_model[-index_excl]
  
  # Calculate likelihood (Probability of choice given the model behaved like participant)
  likelihood = choices_prob_model
  # Check for NA in likelihood vector (means smth went wrong)
  if(any(is.na(likelihood))){
    stop('NA in likelihood vector')
  }
  # Log likelihood
  likelihood = log(likelihood)
  # Sum up log likelihood over all choices
  likelihood = sum(likelihood)
  # Negative log likelihood
  likelihood = -likelihood
  
  # Fuse LL and model data across grid search
  ans = data.table(ll = likelihood, alpha = alpha)
  grid_search_ll = rbind(grid_search_ll, ans)
  grid_search_data = rbind(grid_search_data, test_data)
}



# Plot LL based on alpha
ggplot(data = grid_search_ll,
       aes(x = alpha,
           y = ll)) +
  geom_point(size = 0.5) +
  geom_line()
```

## Recovery

```{r}
rw_recovery = data.table()

# For x number of fitting processes
for(i in seq(2)){
  # Fit model to simulated data (simulated data stems from parameters we know to be the true values)
  solution = Fit_model(data = simulated_data,
                       model = 'Rw',
                       start_values = c(runif(1, 0, 1),
                                        runif(1, 1, 10)),
                       lb = c(0,
                              1),
                       ub = c(1,
                              10))
  # Save fitting details with results into data frame
  result = data.table(i = i,
                      first_x0_alpha = solution$first_x0[1],
                      first_x0_temp = solution$first_x0[2],
                      first_alpha = solution$first_solution[1],
                      first_temp = solution$first_solution[2],
                      first_ll = solution$first_ll,
                      first_status = solution$first_status,
                      second_x0_alpha = solution$second_x0[1],
                      second_x0_temp = solution$second_x0[2],
                      second_alpha = solution$second_solution[1],
                      second_temp = solution$second_solution[2],
                      second_ll = solution$second_ll,
                      second_status = solution$second_status)
  # Append data frame for each loop
  rw_recovery = rbind(rw_recovery, result)
}

# Plot recovery with true parameters
ggplot(data = rw_recovery,
       aes(x = first_x0_alpha,
           y = second_alpha)) +
  geom_hline(yintercept = true_parameters$alpha) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

ggplot(data = rw_recovery,
       aes(x = first_x0_temp,
           y = second_temp)) +
  geom_hline(yintercept = true_parameters$temperature) +
  geom_point() +
  scale_x_continuous(limits = c(1,10)) +
  scale_y_continuous(limits = c(1,10))
```

---

# Pedlr

## Simulate data

```{r}
true_parameters = data.frame(alpha0 = 0.1,
                             alpha1 = 0.7,
                             temperature = 5,
                             reward_space_ub = 100,
                             choice_policy = 'softmax')

# Change choices of data to that of a Rw model
source_model = Pedlr(design = data,
                     params.alpha0 = true_parameters$alpha0,
                     params.alpha1 = true_parameters$alpha1,
                     params.temperature = true_parameters$temperature,
                     params.reward_space_ub = true_parameters$reward_space_ub,
                     choice_policy = true_parameters$choice_policy,
                     init_values = c(50,50,50))
simulated_data = data %>%
  .[, ':='(choice = source_model$choices$choice,
           choice_prob = source_model$choices$choice_prob,
           forced_choice = source_model$choices$forced_choice,
           v_stim_1 = source_model$values$stim_1,
           v_stim_2 = source_model$values$stim_2,
           v_stim_3 = source_model$values$stim_3,
           # No errors possible in simulation
           error = FALSE)] %>%
  # Add comparison type for each trial (e.g. 1v2)
  Add_comp(.) %>%
  # Update outcome to reflect choice of model, not of participant
  .[, trial := seq(.N)] %>%
  .[, outcome := c(reward_stim_1, reward_stim_2)[which(c(option_left, option_right) == choice)],
    by = trial] %>%
  # Select important columns
  .[, c('option_left', 'option_right', 'reward_stim_1', 'reward_stim_2','error',
        'outcome', 'trial_type', 'forced_left', 'forced_right',
        'choice', 'choice_prob', 'forced_choice',
        'v_stim_1', 'v_stim_2', 'v_stim_3', 'comp')]
```

## Grid search

```{r}
grid_search_ll = data.table()
grid_search_data = data.table()

loop_count = 0

for(alpha0 in seq(0,1, by = 0.03)){
  for(alpha1 in seq(0,1, by = 0.03)){
    
    loop_count = loop_count + 1
    
    # Set parameters for each loop
    parameters = data.frame(alpha0 = alpha0,
                            alpha1 = alpha1,
                            temperature = true_parameters$temperature,
                            reward_space_ub = true_parameters$reward_space_ub,
                            choice_policy = true_parameters$choice_policy)
    # Fit model to simulated data with the given parameters
    fitted_model = Fit_Pedlr(data = simulated_data,
                             params.alpha0 = parameters$alpha0,
                             params.alpha1 = parameters$alpha1,
                             params.temperature = parameters$temperature,
                             params.reward_space_ub = parameters$reward_space_ub,
                             choice_policy = parameters$choice_policy,
                             init_values = c(50,50,50))
    # Combine simulated data and fit results into one data frame (add columns of fitting process, like model choices and estimates)
    test_data = simulated_data %>%
      .[, ':='(Pedlr_choice = fitted_model$choices$choice,
               Pedlr_choice_prob = fitted_model$choices$choice_prob,
               Pedlr_forced_choice = fitted_model$choices$forced_choice,
               Pedlr_v_1 = fitted_model$values$stim_1,
               Pedlr_v_2 = fitted_model$values$stim_2,
               Pedlr_v_3 = fitted_model$values$stim_3)]
    
    # Get choices of participant
    choices_participant = simulated_data$choice
    # Get choices and probability of choices from model
    choices_model = fitted_model$choices$choice
    choices_prob_model = fitted_model$choices$choice_prob
    
    # Get forced choices to exclude from likelihood calculation (since here there is no
    # choice probability and in turn no likelihood of choice)
    index_fc = which((simulated_data$trial_type == 'forced'))
    
    # Get time out trials (outcome = NA) to exclude
    index_to = which(is.na(simulated_data$outcome))
    
    # Exclude forced choices and time outs
    index_excl = unique(sort(c(index_fc, index_to)))
    choices_prob_model = choices_prob_model[-index_excl]
    
    # Calculate likelihood (Probability of choice given the model behaved like participant)
    likelihood = choices_prob_model
    # Check for NA in likelihood vector (means smth went wrong)
    if(any(is.na(likelihood))){
      stop('NA in likelihood vector')
    }
    # Log likelihood
    likelihood = log(likelihood)
    # Sum up log likelihood over all choices
    likelihood = sum(likelihood)
    # Negative log likelihood
    likelihood = -likelihood
    
    # Fuse LL and model data across grid search
    ans = data.table(ll = likelihood,
                     alpha0 = parameters$alpha0,
                     alpha1 = parameters$alpha1,
                     temp = parameters$temperature)
    grid_search_ll = rbind(grid_search_ll, ans)
  }
}

```

```{r, warning=FALSE}
data_plot = grid_search_ll
data_plot$size = 2
data_plot$size[data_plot$ll == min(data_plot$ll)] = 5
fig = plotly::plot_ly(x = data_plot$alpha0,
                      y = data_plot$alpha1,
                      z = data_plot$ll,
                      type = "scatter3d",
                      mode = 'markers',
                      color = data_plot$ll,
                      size = data_plot$size)
fig
```


## Recovery

```{r}
pedlr_recovery = data.table()
for(i in seq(5)){
  solution = Fit_model(data = simulated_data,
                       model = 'Pedlr',
                       start_values = c(runif(1, 0, 1),
                                        runif(1, 0, 1),
                                        runif(1, 1, 10)),
                       lb = c(0,
                              0,
                              1),
                       ub = c(1,
                              1,
                              10))
  result = data.table(i = i,
                      first_x0_alpha0 = solution$first_x0[1],
                      first_x0_alpha1 = solution$first_x0[2],
                      first_x0_temp = solution$first_x0[3],
                      first_alpha0 = solution$first_solution[1],
                      first_alpha1 = solution$first_solution[2],
                      first_temp = solution$first_solution[3],
                      first_ll = solution$first_ll,
                      first_status = solution$first_status,
                      second_x0_alpha0 = solution$second_x0[1],
                      second_x0_alpha1 = solution$second_x0[2],
                      second_x0_temp = solution$second_x0[3],
                      second_alpha0 = solution$second_solution[1],
                      second_alpha1 = solution$second_solution[2],
                      second_temp = solution$second_solution[3],
                      second_ll = solution$second_ll,
                      second_status = solution$second_status)
  pedlr_recovery = rbind(pedlr_recovery, result)
}

ggplot(data = pedlr_recovery,
       aes(x = first_x0_alpha0,
           y = second_alpha0)) +
  geom_hline(yintercept = true_parameters$alpha0) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

ggplot(data = pedlr_recovery,
       aes(x = first_x0_alpha1,
           y = second_alpha1)) +
  geom_hline(yintercept = true_parameters$alpha1) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

ggplot(data = pedlr_recovery,
       aes(x = first_x0_temp,
           y = second_temp)) +
  geom_hline(yintercept = true_parameters$temperature) +
  geom_point() +
  scale_x_continuous(limits = c(1,10)) +
  scale_y_continuous(limits = c(1,10))
```

---

# Pedlr_interdep

## Simulate data

```{r}
true_parameters = data.frame(alpha0 = 0.1,
                             alpha1 = 0.7,
                             interdep = 0.1,
                             temperature = 5,
                             reward_space_ub = 100,
                             choice_policy = 'softmax')

# Change choices of data to that of a Rw model
source_model = Pedlr_interdep(design = data,
                              params.alpha0 = true_parameters$alpha0,
                              params.alpha1 = true_parameters$alpha1,
                              params.interdep = true_parameters$interdep,
                              params.temperature = true_parameters$temperature,
                              params.reward_space_ub = true_parameters$reward_space_ub,
                              choice_policy = true_parameters$choice_policy,
                              init_values = c(50,50,50))
simulated_data = data %>%
  .[, ':='(choice = source_model$choices$choice,
           choice_prob = source_model$choices$choice_prob,
           forced_choice = source_model$choices$forced_choice,
           v_stim_1 = source_model$values$stim_1,
           v_stim_2 = source_model$values$stim_2,
           v_stim_3 = source_model$values$stim_3,
           # No errors possible in simulation
           error = FALSE)] %>%
  # Add comparison type for each trial (e.g. 1v2)
  Add_comp(.) %>%
  # Update outcome to reflect choice of model, not of participant
  .[, trial := seq(.N)] %>%
  .[, outcome := c(reward_stim_1, reward_stim_2)[which(c(option_left, option_right) == choice)],
    by = trial] %>%
  # Select important columns
  .[, c('option_left', 'option_right', 'reward_stim_1', 'reward_stim_2','error',
        'outcome', 'trial_type', 'forced_left', 'forced_right',
        'choice', 'choice_prob', 'forced_choice',
        'v_stim_1', 'v_stim_2', 'v_stim_3', 'comp')]
```

## Grid search

```{r}
grid_search_ll = data.table()
grid_search_data = data.table()

loop_count = 0

for(alpha0 in seq(0,1, by = 0.05)){
  for(alpha1 in seq(0,1, by = 0.05)){
    
    loop_count = loop_count + 1
    
    # Set parameters for each loop
    parameters = data.frame(alpha0 = alpha0,
                            alpha1 = alpha1,
                            interdep = true_parameters$interdep,
                            temperature = true_parameters$temperature,
                            reward_space_ub = true_parameters$reward_space_ub,
                            choice_policy = true_parameters$choice_policy)
    # Fit model to simulated data with the given parameters
    fitted_model = Fit_Pedlr_interdep(data = simulated_data,
                                      params.alpha0 = parameters$alpha0,
                                      params.alpha1 = parameters$alpha1,
                                      params.interdep = parameters$interdep,
                                      params.temperature = parameters$temperature,
                                      params.reward_space_ub = parameters$reward_space_ub,
                                      choice_policy = parameters$choice_policy,
                                      init_values = c(50,50,50))
    # Combine simulated data and fit results into one data frame (add columns of fitting process, like model choices and estimates)
    test_data = simulated_data %>%
      .[, ':='(Pedlr_interdep_choice = fitted_model$choices$choice,
               Pedlr_interdep_choice_prob = fitted_model$choices$choice_prob,
               Pedlr_interdep_forced_choice = fitted_model$choices$forced_choice,
               Pedlr_interdep_v_1 = fitted_model$values$stim_1,
               Pedlr_interdep_v_2 = fitted_model$values$stim_2,
               Pedlr_interdep_v_3 = fitted_model$values$stim_3)]
    
    # Get choices of participant
    choices_participant = simulated_data$choice
    # Get choices and probability of choices from model
    choices_model = fitted_model$choices$choice
    choices_prob_model = fitted_model$choices$choice_prob
    
    # Get forced choices to exclude from likelihood calculation (since here there is no
    # choice probability and in turn no likelihood of choice)
    index_fc = which((simulated_data$trial_type == 'forced'))
    
    # Get time out trials (outcome = NA) to exclude
    index_to = which(is.na(simulated_data$outcome))
    
    # Exclude forced choices and time outs
    index_excl = unique(sort(c(index_fc, index_to)))
    choices_prob_model = choices_prob_model[-index_excl]
    
    # Calculate likelihood (Probability of choice given the model behaved like participant)
    likelihood = choices_prob_model
    # Check for NA in likelihood vector (means smth went wrong)
    if(any(is.na(likelihood))){
      stop('NA in likelihood vector')
    }
    # Log likelihood
    likelihood = log(likelihood)
    # Sum up log likelihood over all choices
    likelihood = sum(likelihood)
    # Negative log likelihood
    likelihood = -likelihood
    
    # Fuse LL and model data across grid search
    ans = data.table(ll = likelihood,
                     alpha0 = parameters$alpha0,
                     alpha1 = parameters$alpha1,
                     interdep = parameters$interdep,
                     temp = parameters$temperature)
    grid_search_ll = rbind(grid_search_ll, ans)
  }
}

```

```{r, warning=FALSE}
data_plot = grid_search_ll
data_plot$size = 2
data_plot$size[data_plot$ll == min(data_plot$ll)] = 5
fig = plotly::plot_ly(x = data_plot$alpha0,
                      y = data_plot$alpha1,
                      z = data_plot$ll,
                      type = "scatter3d",
                      mode = 'markers',
                      color = data_plot$ll,
                      size = data_plot$size)
fig
```

## Recovery

```{r}
pedlr_interdep_recovery = data.table()
for(i in seq(5)){
  solution = Fit_model(data = simulated_data,
                       model = 'Pedlr_interdep',
                       start_values = c(runif(1, 0, 1),
                                        runif(1, 0, 1),
                                        runif(1, 0, 1),
                                        runif(1, 1, 10)),
                       lb = c(0,
                              0,
                              0,
                              1),
                       ub = c(1,
                              1,
                              1,
                              10))
  result = data.table(i = i,
                      first_x0_alpha0 = solution$first_x0[1],
                      first_x0_alpha1 = solution$first_x0[2],
                      first_x0_interdep = solution$first_x0[3],
                      first_x0_temp = solution$first_x0[4],
                      first_alpha0 = solution$first_solution[1],
                      first_alpha1 = solution$first_solution[2],
                      first_interdep = solution$first_solution[3],
                      first_temp = solution$first_solution[4],
                      first_ll = solution$first_ll,
                      first_status = solution$first_status,
                      second_x0_alpha0 = solution$second_x0[1],
                      second_x0_alpha1 = solution$second_x0[2],
                      second_x0_interdep = solution$second_x0[3],
                      second_x0_temp = solution$second_x0[4],
                      second_alpha0 = solution$second_solution[1],
                      second_alpha1 = solution$second_solution[2],
                      second_interdep = solution$second_solution[3],
                      second_temp = solution$second_solution[4],
                      second_ll = solution$second_ll,
                      second_status = solution$second_status)
  pedlr_interdep_recovery = rbind(pedlr_interdep_recovery, result)
}

ggplot(data = pedlr_interdep_recovery,
       aes(x = first_x0_alpha0,
           y = second_alpha0)) +
  geom_hline(yintercept = true_parameters$alpha0) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

ggplot(data = pedlr_interdep_recovery,
       aes(x = first_x0_alpha1,
           y = second_alpha1)) +
  geom_hline(yintercept = true_parameters$alpha1) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

ggplot(data = pedlr_interdep_recovery,
       aes(x = first_x0_interdep,
           y = second_interdep)) +
  geom_hline(yintercept = true_parameters$interdep) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

ggplot(data = pedlr_interdep_recovery,
       aes(x = first_x0_alpha1,
           y = second_alpha1)) +
  geom_hline(yintercept = true_parameters$alpha1) +
  geom_point() +
  scale_x_continuous(limits = c(0,1)) +
  scale_y_continuous(limits = c(0,1))

```


